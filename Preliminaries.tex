\section{Preliminaries}\label{sec:preliminaries}
Where we put all the cryptographic preliminaries.

\subsection{Group Implicitly Authenticated Key Exchange}\label{subsec:GIAKE}
\jiaxin{I probably won't use the term "implicitly authenticated" because people are very obsessed with these explicit vs. implicit authentication and have strong opinions on it, but just state authenticated and define weak forward secrecy for it.}
\mattia{I will specify that we mean entity authentication, and by means of only the key exchange algorithms and no other extra mechanism or assumption}
A Group Key Exchange (GKE) protocol allows a group of parties to agree on a shared secret key. 
If the key exchange is authenticated, meaning that the entities are somehow authenticated after the protocol run, we talk about Group Authenticated Key Exchange (GAKE); if authentication is achieved without the use of any additional cryptographic primitive (e.g.digital signatures or massage authentication codes), we say that the protocol is implicitly authenticated (and thus GIAKE).

\paragraph{Terminology.} Let us first recall some basic terminology for group key-exchange (GKE) protocols.
A global \textit{session} is an execution of the protocol, consisting of all algorithmic runs (inputs and outputs) and messages exchanged between all parties, resulting in the final computation of the \textit{group key}.
A local \textit{instance} is what a participant computes, influenced by the received and sent messages.
The local instance is run in a \textit{context}, which consists of all the information that does not come directly from algorithmic outputs or received messages, e.g. set of participants, number of sessions, etc.
We call a participant in a GKE session a \textit{party}.

\paragraph{The generic protocol.} We consider the case of an interactive protocol, run by a group $\PartySet = (\Party_1,\allowbreak \Party_2,\dots,\Party_n)$ of $n$ parties, with $2 < n \leq \projectKey$, arranged in a cycle (operations on the indices are taken modulo the group size).
Each party $\User[i]$ holds a static (long-term) key pair $(\ssk_i,\spk_i)$; we assume the existence of a Public-Key Infrastructure (PKI) that allows for public-key look-up.
In particular, we let PKI register the party identities according to some ordering (e.g. time of registration to the PKI), implicitly determining how to sort the participants to a key-exchange session in a sequence.

\begin{plaindef}[GIAKE]\label{def:GKE}
	Let $\projectKey \in \NN$ be the maximum number of parties, and let $\secparam\in \NN$ be the security parameter. 
	Let $\PartySet = (\User[1],\User[2],\dots,\allowbreak \User[n])$ be a list of $n \leq \projectKey$ parties that want to establish a shared secret key.
	A \textit{Group Implicitly Authenticated Key Exchange} (GIAKE) protocol is a tuple of four algorithms $\GIAKE = (\KeyGen, \GAKEIni, \GAKERes, \GAKEDer)$ defined as follows:
	\begin{itemize}
		\item $(\sk,\pk) \getsr \KeyGen(1^\secpar)$: a PPT key-generation algorithm that outputs a uniformly random secret key $\sk$ and the corresponding public key $\pk$.
		Each party $\User[i]$ preventively produces a static key pair $(\ssk_i,\spk_i) \getsr \KeyGen(1^\secpar)$ and registers the public key $\spk_i$ to the PKI;
		\item $(m_i,\st) \getsr \GAKEIni (\ssk_i,(\spk_j)_{1\leq j \leq n})$: a PPT session initialisation algorithm that, on input a party's static secret key $\ssk_i$ and the static public keys of the intended participants in the session, outputs a message $\messageIni$ and a state $\st$;
		\item $(\hat{m}_i,\st) \gets \GAKERes(\ssk_i,\st,(\spk_j,m_j)_{1\leq j \leq n})$: a (possibly PPT) algorithm that, on input a party's static secret key $\ssk_i$, a state $\st$ and the messages $m_j$ (each broadcasted by the party with static public key $\spk_j$ after running the $\GAKEIni$ algorithm), outputs a message $\hat{m}_i$ and updates the state $\st$;
		\item $K \gets \GAKEDer (\spk_i,\st,(\spk_j,m_j,\hat{m}_j)_{1\leq j \leq n})$: a deterministic algorithm that,  on input a party's static secret key $\ssk_i$, a state $\st$ and the messages $(m_j,\hat{m}_j)$ output by each party $\User[j]$ with static public key $\spk_j$, derives a session key.
	\end{itemize}
	The scheme must implicitly guarantee authentication, i.e. without the use of other primitives.
\end{plaindef}	

\begin{figure}
	\centering 
	
	\begin{tikzpicture}
		\matrix (m)[matrix of nodes, column  sep=1em,row  sep=1mm,%
		column 2/.style={minimum width={width(" $(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1,j\neq i}$")},anchor=center},% 
		column 3/.style={minimum width=6em,anchor=center} ]{
			%line 1
			\underline{$\User[i](\ssk_i, \spk_i)$}& & \underline{$\PartySet\setminus\{\User[i]\}$} \\[2mm]
			%line 2
			$(m_i,\st) \getsr \GAKEIni (\ssk_i,(\spk_j)_{0\leq j \leq n-1})$ & &\\
			%line 3
			& $(\spk_i,m_i)$ & \\
			%line 4
			& $(\spk_j,m_j)_{0\leq j \leq n-1,j\neq i}$ & \\
			%line 5
			$(\hat{m}_i,\st) \gets \GAKERes(\ssk_i,\st,(\spk_j,m_j)_{0\leq j \leq n-1})$ & & \\ 
			%line 6
			& $(\spk_i,\hat{m}_i)$ & \\
			%line 7
			& $(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1,j\neq i}$ & \\
			%line 8
			$K \gets \GAKEDer (\spk_i,\st,(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1})$ & & \\ 
		};
		% drawing arrows
		\draw[-latex] (m-3-2.south west)--(m-3-2.south east);
		\draw[-latex] (m-4-2.south east)--(m-4-2.south west);
		\draw[-latex] (m-6-2.south west)--(m-6-2.south east);
		\draw[-latex] (m-7-2.south east)--(m-7-2.south west);
		\draw (m-8-1.south west) rectangle (m-1-3.north east);
	\end{tikzpicture}
	\caption{A $\GIAKE$ protocol flow from party $\User[i]$'s point of view. All messages (both sent and received ones) are broadcasted to all parties.}\label{fig:giakeprocedure}
\end{figure}

	We now describe a protocol run as viewed by party $\User[i]$, an illustration of which is given in \Cref{fig:giakeprocedure}.
	In the setup phase, each party $\User[i]$ generates a static key-pair $(\ssk_i,\spk_i) \gets \KeyGen(1^\secpar)$ and registers the public part $\spk_i$ to the PKI.
	In the first round, each party runs the initialisation algorithm \[(m_i,\st) \getsr \GAKEIni (\ssk_i,(\spk_j)_{1\leq j \leq n})\] on input its static secret key and the intended parties' public keys. 
	The resulting outputs are an internal state $\st$ and a message $m_i$, the latter of which is broadcasted together with $\spk_i$.
	Upon retrieving $\{(\spk_j,m_j)\}_{1\leq j \leq n, j \neq i}$ from the broadcast channel, each party runs the response algorithm \[(\hat{m}_i,\st) \gets \GAKERes(\ssk_i,\st,(\spk_j,m_j)_{1\leq j \leq n})\], updating its internal state and broadcasting $(\spk_i,\hat{m}_i)$.
	In the last phase, each party derives the group key for the session by running \[K \gets \GAKEDer (\spk_i,\st,(\spk_j,m_j,\hat{m}_j)_{1\leq j \leq n})\].
	
	In broad terms, a GIAKE protocol must be \textit{correct} (each honest party can successfully compute the group key at the end of an honest session), \textit{implicitly authenticated} (the four algorithms in $\GIAKE$ are sufficient for each party to rest assured that nobody but the intended participants may gain access to the session key) and secure (the meaning of which varies; see \Cref{subsec:secmodel}).

\subsection{Security model for GIAKE}\label{subsec:secmodel}
We now describe a security model for a two-round broadcast group authenticated key exchange, that allows a set of $n > 2$ parties to establish a common secret key.
The adversarial model is borrowed from \cite[Section 6.1]{PQR22}, which is in itself an extension to $\projectKey$ parties of the model described in \cite{JKRS20}.
Since we aim for implicit authentication for our 2-round protocol, we have to content ourselves with the notion of \textit{weak Forward Secrecy} (wFS), since no unsigned 2-round key-exchange protocol can hope for (full) Forward Secrecy \cite[Section 3.2]{HMQV}.
In particular, w.r.t. \cite[Section 6.1]{PQR22} we do not allow the adversary to actively participate in the session.\mattia{Argument: the adversary can act like party $\User[i]$ sending an ephemeral key of its choice, since it is unauthenticated. Then it reveals the long-term key of $\User[i]$ and computes the session key.}

In this security model, no mechanism to provide explicit message authentication is considered.
Instead, implicit authentication implies that only the intended honest parties can successfully compute the group key for the session.

\begin{figure}[h!]
	\centering
	\scalebox{0.90}{
		\fbox{\small
			\begin{minipage}[t]{7.5cm}
				\underline{\textbf{GAME} $\GIAKEsecurityPFSGame$} 
				\begin{nicodemus}[1]
					\item $\pcfor n \in [\mu]$
					\item \quad $(\pk_n, \sk_n) \leftarrow \KeyGen(\secparam)$
					\item $b\getsr \{0,1\}$
					\item $b' \gets	\Adv^{O}(\pk_1, \cdots, \pk_\mu)$
					\item \pcfor $\sID^*\in\testSessions$:
					\item \quad \pcif $\FreshnessO(\sID^*)=\pcfalse$
					\item \quad \quad $\pcreturn 0$\gcom{session not fresh}\label{line:gakefreshness}
					\item \quad \pcif $\ValidAttackO(\sID^*)=\pcfalse$
					\item \quad \quad  $\pcreturn 0$\gcom{no valid attack}
					\item $\pcreturn \bool{b=b'}$ \\
				\end{nicodemus}
				\underline{$\GakeIniO ( \GIni  \in [\mu], \PartySet_{i} \subseteq [\mu])$}
				\begin{nicodemus}
					\item $\cntS~\incr$
					\item $\sID \coloneqq \cntS$
					\item $\owner[\sID]:=\GIni $ 
					\item $\peer[\sID]:=\PartySet{i} $
					\item $\GakeUSet[\sID] \coloneqq \peer[\sID] \cup \{\GIni\}$
					\item $(\GakeIniMes_{i}, \Gstate) \getsr \GakeIni(\GakeSk[{i}], \{\GakePk[j]\}_{j \in \PartySet{i}})$
					\item $\GIniMes[\sID]:= ({i},\GakeIniMes_{i}) $
					\item $\Gstates[\sID]:=\Gstate$
					\item $\pcreturn (\sID, \GakeIniMes_{i})$\\
				\end{nicodemus}

				\underline{$\GakeResO(\sID \in [\cntS], \GakeIniMesSet[{i}] )$} %\gcom{$\GakeIniMesSet[{i}]$ is a set of messages}
				\begin{nicodemus}
					\item $(\GIni,\PartySet{i}) := (\owner[\sID],\peer[\sID])$
					\item \pcif $|\GakeIniMesSet[{i}]| \neq |\PartySet{i}|$ 
					\item \quad  \pcreturn $\bot$ 
					\gcom{all peers must have broadcasted}
					\item $\peercorrupted[\sID] := \bigvee\limits_{ j \in \PartySet{i}} \corrupted[j]$
					\item $\GIniMesSet[\sID] \coloneqq  \GakeIniMesSet[{i}]$ \label{line:gake-problem-a}
					\item $(\GakeResMes_{i}, \Gstate) \getsr \GakeRes(\GakeSk[\GIni], \{\GakePk[j]\}_{j \in \PartySet{i}}, \Gstates[\GakeResUsID], \GakeIniMesSet[{i}])$
					\item $\GResMes[\sID]:=({i},\GakeResMes_{i})$
					\item $\Gstates[\sID]:= \Gstate$
					\item \pcreturn $\GakeResMes_{i}$ 
				\end{nicodemus}
			\end{minipage}
			\begin{minipage}[t]{7cm}
				\underline{$\GakeDerO(\GakeResUsID \in [\cntS],  \GakeResMesSet[{i}])$} 
				\begin{nicodemus}
					\item \pcif $\skeys[\GakeResUsID] \neq \bot$  
					\item \quad \pcreturn $\bot$
					\item $({i},\PartySet{i}) := (\owner[\GakeResUsID],\peer[\GakeResUsID])$
					\item \pcif $|\GakeResMesSet[{i}]| \neq |\PartySet{i}|$ \pcreturn $\bot$
					\item $\peercorrupted[\sID] := \bigvee\limits_{ j \in \PartySet{i}} \corrupted[j]$
					\item $\GResMesSet[\sID] \coloneqq \GakeResMesSet[{i}]$ \label{line:gake-problem-b}
					\item $\GakeIniMesSet[{i}] \coloneqq \GIniMesSet[\sID]$
					\item $\GakeSessKey \coloneqq \GakeDer(\GakeSk[{i}], \{\GakePk[j]\}_{j \in \PartySet{i}}, \Gstates[\GakeResUsID], \GakeIniMesSet[{i}], \GakeResMesSet[{i}])$
					\item $\skeys[\GakeResUsID] :=  \GakeSessKey$
					\item \pcreturn $\emptystr$\\
				\end{nicodemus}
				\underline{$\RevealO(\sID)$}
				\begin{nicodemus}
					\item $\revealed[\sID] \coloneqq \true$
					\item $\pcreturn \skeys[\sID]$	\\	
				\end{nicodemus}
				
				\underline{$\CorruptO(n \in [\mu])$}
				\begin{nicodemus}
					\item $\corrupted[n] := \true$
					\item $\pcreturn \sk_n$\\
				\end{nicodemus}
				
				\underline{$\TestO(\sID$)}
				\begin{nicodemus}
					\item $\pcif \sid\in\testSessions~ \pcreturn \bot$ \gcom{already tested}
					\item \pcif $\skeys[\sID] = \bot$~\pcreturn $\bot$
					\item $\testSessions \coloneqq \testSessions \cup \{\sid\}$
					\item $K_0^* \coloneqq \skeys[\sID]$
					\item $K_1^* \getsr \mathcal{K}$
					\item \pcreturn $K_b^*$
				\end{nicodemus}
			\end{minipage}
	}}
	\caption{
	Game $\GIAKEsecurityPFSGame$ for $\GIAKE$.
	The number of messages in the set $\GakeIniMesSet[\GakeUId]$ is denoted by $|\GakeIniMesSet[\GakeUId]|$, and 
	$|\peers_\GakeUId|$ denotes the number of parties in $\peers_\GakeUId$.
	\label{fig:game-ind-atk-gake}}
\end{figure}


%\heading{Execution environment.} We consider $\mu$ parties $\PartySet = (\User[1], \ldots, \User[\mu])$ with long-term key pairs $(\pk_i, \sk_i), i \in [\mu]$. For each group key exchange, each party in a group $\GakeUSet$ has their own session with a unique identification number $\sID$, and variables which are defined relative to $\sID$:
%
%\begin{itemize}
%	\item $\owner[\sID] \in [\mu]$ denotes the owner of the session.
%	\item $\peer[\sID] \subseteq[\mu]$ denotes the peers of the session.
%	\item $\GakeUSet[\sID]$ denotes all the participants of the session.
%	%	\item $\GakeUSet[\sID]$ denotes all the group members. %(i.e. $\peer[\sID]\cup \{\owner[\sID]\}$).
%	\item $\GIniMes[\sID]$ denotes the message sent by the owner during the first round.
%	\item $\GIniMesSet[\sID]$ denotes the messages received by the owner during the first round.
%	\item $\GResMes[\sID]$ denotes the message sent by the owner during the second round.
%	\item $\GResMesSet[\sID]$ denotes the messages received by the owner during the second round.
%	\item $\Gstates[\sID]$ denotes the (secret) state information {\ie} ephemeral secret keys.
%	\item $\ListGakeSessKey[\sID]$ denotes the session key.
%\end{itemize}
%
%\heading{Adversary model.} Similar to the $\AKE$ security notion, we do not allow the adversary to register adversarially controlled parties by providing long-term public keys, and the adversary has access to oracles $\CorruptO$ and $\RevealO$ as described in ~\cref{fig:game-ind-atk-gake}. We use the following boolean values to store which queries the adversary made:
%
%\begin{itemize}
%	\item $\corrupted[{i}]$ denotes whether the long-term secret key of party $\User[{i}]$ was given to the adversary.
%	\item $\revealed[\sID]$ denotes whether the group session key was given to the adversary.
%	\item $\peercorrupted[\sID]$ denotes whether one of the peers in the group was corrupted and its long-term key was given to the adversary at the time when the session key was derived.
%\end{itemize}
%
%
%\heading{Matching sessions.} Extending the definition of matching sessions from the two-party case, we define matching sessions in the $\Gake$ setting as follows.
%%\begin{itemize}
%%	\item \textbf{Matching Sessions}: Given a set of parties $\GakeUSet$ participating in a $\Gake$ session, the set of sessions 
%%	$\{\sID_j\}_{j \in |\GakeUSet |}$ are matching, if there exists $\GakeIniMesSet[{i}], \GakeResMesSet[{i}]$, such that for each $\User[j] \in \GakeUSet$ we have:
%%	$\owner[\sID_j] = \User[j]$, $\peer[\sID_j] = \GakeUSet\setminus\{j\}$, $\GIniMes[\sID_j] = \GakeIniMesSet[{i}]$ and $\GResMes[\sID_j] = \GakeResMesSet[{i}]$. (Notice that, we assume $\GakeUSet$ is an ordered set and $\User[j]$ represents the $j$-th party in $\GakeUSet$. The index $j$ is different from the party's index in the set of all participants $\PartySet$.)
%%\end{itemize}
%\begin{itemize}
%	\item \textbf{Matching Sessions}: Two sessions $\sid_{i}, \sid_j$ are matching if:
%	\begin{align*}
%		\owner[\sID_{i}] &\neq \owner[\sID_j] &&\text{(Different owners)}\\
%		\GakeUSet[\sID_{i}] &= \GakeUSet[\sID_j]  &&\text{(Identical participants)} \\
%		\changehighlight{\{\GIniMes[\sID_{i}]\}} \cup \GIniMesSet[\sID_{i}] &= \changehighlight{\{\GIniMes[\sID_j]\}} \cup \GIniMesSet[\sID_j]   &&\text{(Identical messages in the first round)}\\
%		\changehighlight{\{\GResMes[\sID_{i}]\}} \cup \GResMesSet[\sID_{i}] &= \changehighlight{\{\GResMes[\sID_j]\}}\cup \GResMesSet[\sID_j]  &&\text{(Identical messages in the second round)}
%	\end{align*}
%	%	$\owner[\sID_{i}] \neq \owner[\sID_j]$, $\GakeUSet[\sID_{i}] = \GakeUSet[\sID_j]$, $\GIniMes[\sID_{i}] \cup \GIniMesSet[\sID_{i}]= \GIniMes[\sID_j]\cup \GIniMesSet[\sID_j]$ and $\GResMes[\sID_{i}] \cup \GResMesSet[\sID_{i}]= \GResMes[\sID_j]\cup \GResMesSet[\sID_j]$. %(Notice that, we assume $\GakeUSet$ is an ordered set and $\User[j]$ represents the $j$-th party in $\GakeUSet$. The index $j$ is different from the party's index in the set of all participants $\PartySet$.)
%\end{itemize}
%\changehighlight{As in the $\AKE$ setting, our protocols in the full $\Gake$ model will use signatures, and hence any successful no-match attack as described in~\cite{CCS:LiSch17} will lead to a signature forgery.}
%%\todo{This is probably wrong and needs a fixup like we did for ake.}
%
%
%\heading{Test session.} The adversary is given access to the test oracle $\TestO$. This oracle can be queried multiple times and depending on a randomly chosen bit $b \getsr \bits$ (which is shared between all test queries), it outputs either a uniformly random key, or the specified session key.  
%
%
%%\todo{freshness+ attack table + formal def}
%%\owner[\sID_{i}] \neq \owner[\sID_j]$, $\GakeUSet[\sID_{i}] = \GakeUSet[\sID_j]$, $\GIniMes[\sID_{i}] = \GIniMes[\sID_j]$ and $\GResMes[\sID_{i}] = \GResMes[\sID_j]
%\begin{figure}[h!]
%	\centering
%	\hspace*{-0.1cm}\scalebox{0.92}{
%		\fbox{\small
%			\begin{minipage}[t]{12.7cm}
%				\underline{$\FreshnessO(\sID^*)$}
%				\begin{nicodemus}[1]
%					\item $({i}^\star, \GakeUSet^\star) := (\owner[\sID^*], \GakeUSet[\sID^*])$						
%					\item $\matchingSessions \coloneqq \{\sID \mid   \owner[\sID] \neq  {i}^\star~ \wedge ~ \GakeUSet[\sID]= \GakeUSet^\star ~$\\ 
%					\hspace*{3.2cm}$ \wedge~\changehighlight{\{\GIniMes[\sID]\}} \cup \GIniMesSet[\sID] = \changehighlight{\{\GIniMes[\sID^*]\}}\cup \GIniMesSet[\sID^*] ~$\\
%					\hspace*{3.2cm}$ \wedge~\changehighlight{\{\GResMes[\sID] \}}\cup \GResMesSet[\sID] = \changehighlight{\{\GResMes[\sID^*]\}}\cup \GResMesSet[\sID^*]\}$ \gcom{matching sessions}
%					\item \pcif $\revealed[\sID^*]$ \pcor $(\exists \sID \in \matchingSessions: \revealed[\sID] = \true)$
%					\item \quad \pcreturn $\pcfalse$ \gcom{$\Adv$ trivially learned the test session's key}
%					\item \pcif $\exists\sid\in\matchingSessions \suchthat \sid\in\testSessions$
%					\item \quad \pcreturn $\pcfalse$ \gcom{$\A$ also tested a matching session}
%					\item \pcreturn $\true$
%				\end{nicodemus}
%				\ \\
%				\underline{$\ValidAttackO(\sID^*)$}
%				\begin{nicodemus}
%					\item $({i}^\star, \GakeUSet^\star) := (\owner[\sID^*], \GakeUSet[\sID^*])$						
%					\item $\matchingSessions \coloneqq \{\sID \mid   \owner[\sID] \neq  {i}^\star~ \wedge ~ \GakeUSet[\sID]= \GakeUSet^\star ~$\\ 
%					\hspace*{3.2cm}$ \wedge~\changehighlight{\{\GIniMes[\sID]\}} \cup \GIniMesSet[\sID] = \changehighlight{\{\GIniMes[\sID^*]\}}\cup \GIniMesSet[\sID^*] ~$\\
%					\hspace*{3.2cm}$ \wedge~\changehighlight{\{\GResMes[\sID]\}} \cup \GResMesSet[\sID] = \changehighlight{\{\GResMes[\sID^*]\}}\cup \GResMesSet[\sID^*]\}$ \gcom{matching sessions}
%					\item $\pcfor \attack\in$\hspace*{-0.1em} \cref{tab:wFS-optimized-table-gake} 
%					\item \quad $\pcif \attack=\true~ \pcreturn \true$\label{line:attack-true-2-gake}
%					\item \pcreturn \pcfalse
%				\end{nicodemus}
%			\end{minipage}
%	}}
%	\caption{Helper procedures $\FreshnessO$ and $\ValidAttackO$ for game $\GAKEsecurityPFSGame$ defined in \cref{fig:game-ind-atk-gake}.	Procedure $\FreshnessO$ checks if the adversary performed some trivial attack. In procedure $\ValidAttackO$, each attack is evaluated by the set of variables shown in \cref{tab:wFS-optimized-table-gake} and checks if an allowed attack was performed. If the values of the variables are set as in the corresponding row, the attack was performed, i.\,e.\, $\attack=\true$, and thus the session is valid.
%	}
%	\label{fig:gake-freshness}
%\end{figure}
%
%
%\setlength\extrarowheight{1pt}
%\begin{table}[t]
%	\begin{center}
%		\scalebox{0.92}{
%			\begin{tabular}{|p{0.8cm}p{6cm}|C{.5cm}|C{1.2cm}|}
%				\hline
%				& \begin{minipage}[t][1cm][b]{5cm} $\A$ gets ($\owner[\sid^*], \PartySet{i} \coloneqq \peer[\sid^*]$)\end{minipage}
%				& \rotatebox{90}{\parbox{2.7cm}{$\peercorrupted[\sid^*]$}}& \rotatebox{90}{\parbox{2.5cm}{$|\matchingSessions|$}} \\
%				\hline\hline
%				%
%				0. & {\bf multiple matching sessions}  & --  & $  > |\PartySet{i}|$  \\
%				\hline
%				\hline
%				1. & {\bf (long-term, long-term)}   & --  &  $=|\PartySet{i}|$\\
%				\hline
%				\hline
%				2. & {\bf (long-term, long-term)}  & \tabfalse & $ < |\PartySet{i}|$  \\
%				\hline
%			\end{tabular}
%		}
%	\end{center}
%	\caption{Table of attacks for adversaries against explicitly authenticated group key exchange protocols without ephemeral state reveals. An attack is regarded as an AND conjunction of variables with specified values as shown in the each line, where “--” means that this variable can take arbitrary value and {\tabfalse} means “false”.}
%	\label{tab:wFS-optimized-table-gake}



\subsection{Hash Proof System}\label{subsec:HPF}
We now recall the definitions of smooth projective hashing and hash proof system, introduced for the first time in \cite{CS02} and later picked up in \cite{JKRS20}.

Informally, a projective hash function is a keyed hash function associated with two types of keys: the secret \textit{hashing key}, which allows for hashing of every element in the domain, and a public \textit{projective key}, that can be used to hash only those elements that lie in a designated subset (the language) of the domain.
A projective hash function is \textit{smooth} if the projective key gives only a negligible advantage in correctly hashing an element that lies outside the designated subset.

\begin{definition}[Smooth projective hashing]
	Let $\Domain,\Codomain$ be two sets, let $\Language \subset \Domain$ be a language and let $\SKSpace,\PKSpace$ be the secret and public key spaces.
	For any secret key $\sk \in \SKSpace$, let $\Lambda_{\sk} : \Domain \rightarrow \Codomain$ be a keyed hash function.
	A hash function $\Lambda_{\sk}$ is \textbf{projective} if there exists a projection $\projectKey : \SKSpace \rightarrow \PKSpace$ such that the key $\pk = \projectKey(\sk)$ uniquely defines the action of $\Lambda_\sk$ on $\Language$: For every $\x \in \Language$, the digest $\y = \Lambda_\sk(\x)$ can be consistently computed from $\pk$ and $\x$.
	
	A projective hash function is \textbf{smooth} if, given any hashing key $\sk \getsr \SKSpace$ and its projection key $\pk = \projectKey(\sk)$, there exists only a negligible probability to successfully distinguish between samples from the distributions $D_1$ and $D_2$, where
	\[ D_1 := \{ (\x', \pk, \y) \mid \y = \Lambda_\sk(\x')) \}_{\x' \in \Domain\setminus\Language} \quad \text{and} \quad D_2 := \{(\x', \pk, \y) \mid \y \getsr \Codomain \}_{\x' \in \Domain\setminus\Language}\]
	Equivalently,\mattia{check this, I give a different definition here} let $\adv$ be an adversary that tries to compute the action of $\HPSHash_\sk$ on $\Domain \setminus \Language$ using the projection key $\pk = \projectKey(\sk)$ of a random $\sk \getsr \SKSpace$; then, for any $\x' \in \Domain \setminus \Language$,
	\[ \Pr \left[ \y \gets \adv(\pk,\x')  \mid \y = \HPSHash_\sk(\x') \right] \leq \negl[\secpar]\]\mattia{Possibly add the definition of $k$-entropic}
\end{definition}

Before moving on with the definition of a hash proof system, a few assumptions need to be made.
First, we assume that the projection function $\projectKey$ and the algorithms for sampling elements from $\Domain$ and from $\Language$ are efficient.
Secondly, we assume that for every $\x \in \Language$, one can efficiently produce a witness $w$ proving that $\x$ belongs to the language.

\begin{definition}
	A \textbf{Hash Proof System} (HPS) consists of three algorithms $\HPS = (\HPSParam,\HPSPrivEval,\HPSPubEval)$ defined as follows:
	\begin{itemize}
		\item $\HPSparams: = (\HPSgroup,\Codomain,\Domain,\Language,\SKSpace,\PKSpace,\HPSHash,\projectKey)  \getsr \HPSParam (1^\secpar)$: a PPT parameter setup algorithm that outputs a parameter set $\HPSparams$ containing a possibly empty set $\HPSgroup$ of extra parameters, a codomain $\Codomain$, a domain $\Domain$, a language $\Language$, a hashing key space $\SKSpace$, a projective key space $\PKSpace$, a smooth projective hash function $\HPSHash_{(\cdot)}: \Domain \rightarrow \Codomain$ and a projection function $\projectKey: \SKSpace \rightarrow \PKSpace$;
		\item $\y \gets \HPSPrivEval (\sk,\x)$: a deterministic private hashing algorithm that, on input a secret hashing key $\sk$ and an element $\x \in \Language$, outputs the digest $\y = \HPSHash_\sk(\x)$;
		\item $\y \gets \HPSPubEval (\pk,\x,w)$: a deterministic public hashing algorithm that, on input a projection key $\pk = \mu(\sk)$, an element $\x \in \Language$ and a witness $w$ for the fact that $\x \in \Language$, outputs the digest $\y = \HPSHash_\sk(\x)$.
	\end{itemize}
\end{definition}

The fundamental problem which an HPS bases its security on is the $m$- fold subset membership problem, which asks to tell elements sampled from the language apart from elements sampled in its complement.
\begin{problem}[$m$-fold Subset Membership Problem]
	Given $m$ elements uniformly drawn from $\Language$ and $m$ elements uniformly drawn from $\Domain \setminus \Language$, an adversary $\adv$ has a negligible advantage in distinguishing them; more formally,
	\begin{align*} \AdvSMP :=  & \big| \Pr \left[ 1 \gets \adv(\Domain,\Language,\x_1,\dots,\x_m )  \mid \x_1,\dots,\x_m \getsr \Language \right] - \\
		&\Pr \left[ 1 \gets \adv(\Domain,\Language,\x_1',\dots,\x_m' )  \mid \x_1',\dots,\x_m' \getsr \Domain \setminus \Language \right] \big| \leq \negl[\secpar] 
		\end{align*}
\end{problem}


