\section{Preliminaries}\label{sec:preliminaries}
Where we put all the cryptographic preliminaries.

\subsection{Group Implicitly Authenticated Key Exchange}{subsec:GIAKE}
A Group Key Exchange (GKE) protocol allows a group of parties to agree on a shared secret key. 
If the key exchange is authenticated, we talk about Group Authenticated Key Exchange (GAKE); if authentication is achieved without the use of an additional cryptographic primitive (e.g. by means of a digital signature algorithm), we say that the protocol is implicitly authenticated (and thus GIAKE).

We consider the case of an interactive protocol run by a group $\PartySet = (\Party_0,\allowbreak \Party_1,\dots,\Party_{n-1})$ of $n$ parties, with $2 < n \leq \mu$, arranged as a cycle (operations on the indices are taken modulo the group size).
Each party $\User[i]$ holds a long-term (static) key pair $(\ssk_i,\spk_i)$; we assume the existence of a Public-Key Infrastructure (PKI) that allows users to retrieve the public keys of any other party.
In particular, we let the party identities be registered according to some ordering (e.g. order of registration to the PKI), allowing for the implicit agreement on the sequence of $n$ parties partaking in the key exchange session.

\begin{plaindef}[GIAKE]\label{def:GKE}
	Let $\mu \in \NN$ be the maximum number of parties, and let $\secparam\in \NN$ be the security parameter. 
	Let $\PartySet = (\User[1],\User[2],\dots,\allowbreak \User[n])$ be a list of $n \leq \mu$ parties that want to establish a shared secret key.
	A \textit{Group Implicitly Authenticated Key Exchange} (GIAKE) protocol is a tuple of four algorithms $\GIAKE = (\KeyGen, \GAKEIni, \GAKERes, \GAKEDer)$ defined as follows:
	\begin{itemize}
		\item $(\sk,\pk) \getsr \KeyGen(1^\secpar)$: a PPT key-generation algorithm that outputs a uniformly random secret key $\sk$ and the corresponding public key $\pk$.
		Each party $\User[i]$ preventively produces a static key pair $(\ssk_i,\spk_i) \getsr \KeyGen(1^\secpar)$ and registers the public key $\spk_i$ to the PKI;
		\item $(m_i,\st) \getsr \GAKEIni (\ssk_i,(\spk_j)_{0\leq j \leq n-1})$: a PPT session initialisation algorithm that, on input a party's static secret key $\ssk_i$ and the static public keys of the intended participants in the session, outputs a message $\messageIni$ and a state $\st$;
		\item $(\hat{m}_i,\st) \gets \GAKERes(\ssk_i,\st,(\spk_j,m_j)_{0\leq j \leq n-1})$: a (possibly PPT) algorithm that, on input a party's static secret key $\ssk_i$, a state $\st$ and the messages $m_j$ (each broadcasted by the party with static public key $\spk_j$ after running the $\GAKEIni$ algorithm), outputs a message $\hat{m}_i$ and updates the state $\st$;
		\item $K \gets \GAKEDer (\spk_i,\st,(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1})$: a deterministic algorithm that,  on input a party's static secret key $\ssk_i$, a state $\st$ and the messages $(m_j,\hat{m}_j)$ output by each party $\User[j]$ with static public key $\spk_j$, outputs a session key.
	\end{itemize}
	A GIAKE protocol must be \textit{correct} (each honest party can successfully compute the shared session key) and \textit{implicitly authenticated} (the four algorithms in $\GIAKE$ are sufficient for each party to rest assured that nobody but the intended participants may gain access to the shared session key).
\end{plaindef}

\begin{figure}
	\centering 

		\begin{tikzpicture}
	\matrix (m)[matrix of nodes, column  sep=1em,row  sep=1mm,%
	column 2/.style={minimum width={width(" $(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1,j\neq i}$")},anchor=center},% 
	column 3/.style={minimum width=6em,anchor=center} ]{
		%line 1
	\underline{$\User[i](\ssk_i, \spk_i)$}& & \underline{$\PartySet\setminus\{\User[i]\}$} \\[2mm]
	%line 2
		$(m_i,\st) \getsr \GAKEIni (\ssk_i,(\spk_j)_{0\leq j \leq n-1})$ & &\\
	%line 3
		& $(\spk_i,m_i)$ & \\
	%line 4
		& $(\spk_j,m_j)_{0\leq j \leq n-1,j\neq i}$ & \\
	%line 5
		$(\hat{m}_i,\st) \gets \GAKERes(\ssk_i,\st,(\spk_j,m_j)_{0\leq j \leq n-1})$ & & \\ 
	%line 6
		& $(\spk_i,\hat{m}_i)$ & \\
	%line 7
		& $(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1,j\neq i}$ & \\
	%line 8
		$K \gets \GAKEDer (\spk_i,\st,(\spk_j,m_j,\hat{m}_j)_{0\leq j \leq n-1})$ & & \\ 
	};
	% drawing arrows
	\draw[-latex] (m-3-2.south west)--(m-3-2.south east);
	\draw[-latex] (m-4-2.south east)--(m-4-2.south west);
	\draw[-latex] (m-6-2.south west)--(m-6-2.south east);
	\draw[-latex] (m-7-2.south east)--(m-7-2.south west);
	\draw (m-8-1.south west) rectangle (m-1-3.north east);
	\end{tikzpicture}
		\caption{A $\GIAKE$ protocol flow from party $\User[i]$'s point of view. All messages (both sent and received ones) are broadcasted to all parties.}\label{fig:giakeprocedure}
\end{figure}

\subsection{Security model}\label{subsec:secmodel}
We now describe the security model in which we will prove our protocol secure.
The adversarial model is borrowed from \cite[Section 6.1]{PQR22}, which is in itself an extension to $\mu$ parties of the model described in \cite{JKRS20}.
Since we aim for implicit authentication for our 2-message protocol, we have to content ourselves with the notion of \textit{weak Forward Secrecy} (wFS), since no unsigned 2-message key-exchange protocol can hope for (full) Forward Secrecy \cite[Section 3.2]{HMQV}.
In particular, w.r.t. \cite[Section 6.1]{PQR22} we do not allow the adversary to actively participate in the session.\mattia{Argument: the adversary can act like party $\User[i]$ sending an epheremal key of its choice, since it is unauthenticated. Then it reveals the long-term key of $\User[i]$ and computes the session key.}