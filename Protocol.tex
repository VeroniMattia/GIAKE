\section{Protocol}\label{sec:protocol}
In this section we present our first protocol \mattia{name of the protocol}, presented from the viewpoint of user $\User[i]$.
We then show its correctness, expanding the computation that $\User[i]$ performs in the key-derivation phase.
We prove the protocol secure \mattia{security notion and model} in \Cref{sec:security}.

In the Setup phase, each user $\User[i]$ generates a static key pair $(\ssk_i,\spk_i)$, and registers its public key $\spk_i$ using a PKI.
In the Initialization phase, each user $\User[i]$ retrieves from the PKI the static keys $(\spk_1,\dots,\spk_n)$ of all the participants $\User[1],\dots,\User[n]$  in the key-exchange; then, it generates an ephemeral key pair $(\esk_i,\epk_i)$, and broadcasts the public key $\epk_i$. 
In the Response phase, the user mixes static and ephemeral key material as follows:
\begin{itemize}
	\item it computes the static-on-ephemeral element $\hat{K}_i^\text{(se)} \gets \left( \dfrac{\epk_{i+1}}{\epk_{i-1}}\right)^{\ssk_i}$
	\item it computes the ephemeral-on-static element $\hat{K}_n^\text{(es)} \gets \left( \dfrac{\spk_{i+1}}{\spk_{i-1}}\right)^{\esk_i}$
	\item it computes the ephemeral-on-ephemeral element $\hat{K}_n^\text{ee} \gets \left( \dfrac{\epk_{i+1}}{\epk_{i-1}}\right)^{\esk_i}$ 
\end{itemize}
and it broadcasts the results.
In the Key-derivation phase, it computes the three partial keys $K_i^{(se)}$, $K_i^{(es)}$, $K_i^{(ee)}$ as in \Cref{fig:ourprotocol}, and it multiplies them together to obtain the key $K \gets K_i^{(se)} \cdot K_i^{(es)} \cdot K_i^{(ee)}$.

\textbf{Correctness}. We show that each party $\User[i]$ successfully computes the key $K = g^{e_1s_2 + \dots e_ns_1}\cdot g^{s_1e_2 + \dots s_ne_1}\cdot g^{e_1e_2 + \dots e_ne_1}$

%\begin{figure}
%	\centering 
%	\fbox{
%	\begin{tikzpicture}[ampersand replacement=\&]
%		\matrix (m)[matrix of nodes, column  sep=1.1em,row  sep=1mm,%
%		nodes={anchor=west}]{
%			%Parties
%			\underline{$\User[1](\ssk_1, \spk_1)$}\& \underline{$\User[2](\ssk_2, \spk_2)$} \&  \underline{$\User[n](\ssk_n, \spk_n)$} \\	
%			% Init
%			\hline$_\GAKEIni$ \\
%			fetch$(\spk_2,\spk_3,\dots,\spk_n)$ \& fetch$(\spk_1,\spk_3,\dots,\spk_n)$ \& fetch$(\spk_1,\spk_2,\dots,\spk_{n-1})$\\
%			$(\esk_1,\epk_1) \getsr \KeyGen(1^\secpar)$ \& $(\esk_2,\epk_2) \getsr \KeyGen(1^\secpar)$ \&  $(\esk_n,\epk_n) \getsr \KeyGen(1^\secpar)$  \\
%
%			broadcast($\epk_1$)\&broadcast($\epk_2$) \& broadcast($\epk_n$) \\
%				\hline$_\GAKERes$\\
%			% Resp
%			%fetch($E_2,E_3,\dots,E_n$) \& fetch($E_1,E_3,\dots,E_n$) \& fetch($E_1,E_2,\dots,E_{n-1}$)\\
%			$\hat{K}_1^\text{se} \gets \left( \dfrac{\epk_2}{\epk_n}\right)^{\ssk_1}$ \& $\hat{K}_2^\text{se} \gets \left( \dfrac{\epk_3}{\epk_1}\right)^{\ssk_2}$   \&   $\hat{K}_n^\text{se} \gets \left( \dfrac{\epk_1}{\epk_{n-1}}\right)^{\ssk_n}$ 	\\
%			$\hat{K}_1^\text{es} \gets \left( \dfrac{\spk_2}{\spk_n}\right)^{\esk_1}$ \& $\hat{K}_2^\text{es} \gets \left( \dfrac{\spk_3}{\spk_1}\right)^{\esk_2}$  \& $\hat{K}_n^\text{es} \gets \left( \dfrac{\spk_1}{\spk_{n-1}}\right)^{\esk_n}$	\\
%			$\hat{K}_1^\text{ee} \gets \left( \dfrac{\epk_2}{\epk_n}\right)^{\esk_1}$ \& $\hat{K}_2^\text{ee} \gets \left( \dfrac{\epk_3}{\epk_1}\right)^{\esk_2}$  \&   $\hat{K}_n^\text{ee} \gets \left( \dfrac{\epk_1}{\epk_{n-1}}\right)^{\esk_n}$ 	\\
%			$\hat{m}_1 \gets (\hat{K}_1^\text{se},\hat{K}_1^\text{es},\hat{K}_1^\text{ee})$ \& $\hat{m}_2 \gets (\hat{K}_2^\text{se},\hat{K}_2^\text{es},\hat{K}_2^\text{ee})$ \&  $\hat{m}_n \gets (\hat{K}_n^\text{se},\hat{K}_n^\text{es},\hat{K}_n^\text{ee})$\\
%			broadcast($\hat{m}_1$) \&broadcast($\hat{m}_2$) \& broadcast($\hat{m}_n$) \\
%				\hline$_\GAKEDer$\\
%			$K_i^{se} \gets E_{i-1}^{ns_i} \cdot (\hat{K}_1^\text{se})^{n-1} \cdot (\hat{K}_2^\text{se})^{n-2} \cdots \hat{K}_{n-2}^\text{se}$ \& \& \& \\
%		};
%	\end{tikzpicture}
%	}
%	\caption{Our protocol.}\label{fig:ourprotocol}
%\end{figure}

\begin{figure}
	\centering 
	\fbox{
		\begin{tikzpicture}[ampersand replacement=\&]
			\matrix (m)[matrix of nodes, column  sep=1.1em,row  sep=1mm,%
			nodes={anchor=west}]{
				%Parties
				 \underline{$\User[i](\ssk_i, \spk_i)$}  \\	
				% Init
				\hline$_\GAKEIni$ \\
				fetch$(\spk_1,\spk_2,\dots,\spk_{i-1},\spk_{i+1},\dots,\spk_{n})$\\
				$(\esk_i,\epk_i) \getsr \KeyGen(1^\secpar)$  \\
				broadcast($\epk_i$) \\
				\hline$_\GAKERes$\\
				% Resp
				%fetch($E_2,E_3,\dots,E_n$) \& fetch($E_1,E_3,\dots,E_n$) \& fetch($E_1,E_2,\dots,E_{n-1}$)\\
				$\hat{K}_i^\text{(se)} \gets \left( \dfrac{\epk_{i+1}}{\epk_{i-1}}\right)^{\ssk_i}$ 	\\
				$\hat{K}_n^\text{(es)} \gets \left( \dfrac{\spk_{i+1}}{\spk_{i-1}}\right)^{\esk_i}$ 	\\
				$\hat{K}_n^\text{ee} \gets \left( \dfrac{\epk_{i+1}}{\epk_{i-1}}\right)^{\esk_i}$ 	\\
				$\hat{m}_i \gets (\hat{K}_i^\text{(se)},\hat{K}_i^\text{(es)},\hat{K}_i^\text{ee})$ \\
				broadcast($\hat{m}_i$) \\
				\hline$_\GAKEDer$\\
				$K_i^{(se)} \gets E_{i-1}^{ns_i} \cdot (\hat{K}_i^\text{(se)})^{n-1} \cdot (\hat{K}_{i+1}^\text{(se)})^{n-2} \cdots \hat{K}_{i-2}^\text{(se)}$  \\
				$K_i^{(es)} \gets S_{i-1}^{ne_i} \cdot (\hat{K}_i^\text{(es)})^{n-1} \cdot (\hat{K}_{i+1}^\text{(es)})^{n-2} \cdots \hat{K}_{i-2}^\text{(es)}$  \\
				$K_i^{(ee)} \gets E_{i-1}^{ne_i} \cdot (\hat{K}_i^\text{(ee)})^{n-1} \cdot (\hat{K}_{i+1}^\text{(ee)})^{n-2} \cdots \hat{K}_{i-2}^\text{(ee)}$  \\
				$K \gets K_i^{(se)} \cdot K_i^{(es)} \cdot K_i^{(ee)}$\\
			};
		\end{tikzpicture}
	}
	\caption{Our protocol.}\label{fig:ourprotocol}
\end{figure}